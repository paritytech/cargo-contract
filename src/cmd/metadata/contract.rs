// Copyright 2018-2020 Parity Technologies (UK) Ltd.
// This file is part of cargo-contract.
//
// ink! is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// ink! is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ink!.  If not, see <http://www.gnu.org/licenses/>.

use core::{
	fmt::{
		Display,
		Formatter,
		Result as DisplayResult,
		Write,
	},
	marker::PhantomData,
};
use semver::Version;
use serde::{
	Serialize,
	Serializer,
};
use serde_json::{
	Map,
	Value,
};
use url::Url;

const METADATA_VERSION: &str = "0.1.0";

/// An entire ink! project for metadata file generation purposes.
#[derive(Debug, Serialize)]
pub struct ContractMetadata {
	metadata_version: semver::Version,
	source: InkProjectSource,
	contract: InkProjectContract,
	#[serde(skip_serializing_if = "Option::is_none")]
	user: Option<InkProjectUser>,
	/// Raw JSON of the metadata generated by the ink! contract itself
	#[serde(flatten)]
	ink: Map<String, Value>,
}

impl ContractMetadata {
	/// Construct a new ContractMetadata
	pub fn new(source: InkProjectSource,
			   contract: InkProjectContract,
			   user: Option<InkProjectUser>, ink: Map<String, Value>) -> Self
	{
		let metadata_version = semver::Version::parse(METADATA_VERSION)
			.expect("METADATA_VERSION is a valid semver string");

		ContractMetadata {
			metadata_version,
			source,
			contract,
			user,
			ink,
		}
	}
}

#[derive(Debug, Serialize)]
pub struct InkProjectSource {
	#[serde(serialize_with = "serialize_as_byte_str")]
	hash: [u8; 32],
	language: SourceLanguage,
	compiler: SourceCompiler,
}

impl InkProjectSource {
	/// Constructs a new InkProjectSource.
	pub fn new(
		hash: [u8; 32],
		language: SourceLanguage,
		compiler: SourceCompiler,
	) -> Self {
		InkProjectSource {
			hash,
			language,
			compiler,
		}
	}
}

/// The language and version in which a smart contract is written.
#[derive(Debug)]
pub struct SourceLanguage {
	language: Language,
	version: Version,
}

impl SourceLanguage {
	/// Constructs a new SourceLanguage.
	pub fn new(language: Language, version: Version) -> Self {
		SourceLanguage { language, version }
	}
}

impl Serialize for SourceLanguage {
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
		where
			S: Serializer,
	{
		serializer.serialize_str(&format!("{} {}", self.language, self.version))
	}
}

/// The language in which the smart contract is written.
#[derive(Debug)]
pub enum Language {
	Ink,
	Solidity,
	AssemblyScript,
	Other(&'static str),
}

impl Display for Language {
	fn fmt(&self, f: &mut Formatter<'_>) -> DisplayResult {
		match self {
			Self::Ink => write!(f, "ink!"),
			Self::Solidity => write!(f, "Solidity"),
			Self::AssemblyScript => write!(f, "AssemblyScript"),
			Self::Other(lang) => write!(f, "{}", lang),
		}
	}
}

/// A compiler used to compile a smart contract.
#[derive(Debug)]
pub struct SourceCompiler {
	compiler: Compiler,
	version: Version,
}

impl Serialize for SourceCompiler {
	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
		where
			S: Serializer,
	{
		serializer.serialize_str(&format!("{} {}", self.compiler, self.version))
	}
}

impl SourceCompiler {
	pub fn new(compiler: Compiler, version: Version) -> Self {
		SourceCompiler { compiler, version }
	}
}

/// Compilers used to compile a smart contract.
#[derive(Debug, Serialize)]
pub enum Compiler {
	RustC,
	Solang,
	Other(&'static str),
}

impl Display for Compiler {
	fn fmt(&self, f: &mut Formatter<'_>) -> DisplayResult {
		match self {
			Self::RustC => write!(f, "rustc"),
			Self::Solang => write!(f, "solang"),
			Self::Other(other) => write!(f, "{}", other),
		}
	}
}

/// Metadata about a smart contract.
#[derive(Debug, Serialize)]
pub struct InkProjectContract {
	name: String,
	version: Version,
	authors: Vec<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	description: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	documentation: Option<Url>,
	#[serde(skip_serializing_if = "Option::is_none")]
	repository: Option<Url>,
	#[serde(skip_serializing_if = "Option::is_none")]
	homepage: Option<Url>,
	#[serde(skip_serializing_if = "Option::is_none")]
	license: Option<License>,
}

impl InkProjectContract {
	/// Constructs a new InkProjectContractBuilder.
	pub fn build() -> InkProjectContractBuilder<
		Missing<state::Name>,
		Missing<state::Version>,
		Missing<state::Authors>,
	> {
		InkProjectContractBuilder {
			contract: Self {
				name: Default::default(),
				version: Version::new(0, 0, 0),
				authors: vec![],
				description: None,
				documentation: None,
				repository: None,
				homepage: None,
				license: None,
			},
			marker: Default::default(),
		}
	}
}

/// The license of a smart contract
#[derive(Debug, Serialize)]
pub enum License {
	/// An [SPDX identifier](https://spdx.org/licenses/)
	SpdxId(String),
	/// A URL to a custom license
	Link(Url),
}

/// Additional user defined metadata, can be any valid json.
#[derive(Debug, Serialize)]
pub struct InkProjectUser {
	#[serde(flatten)]
	json: Map<String, Value>,
}

impl InkProjectUser {
	/// Constructs a new InkProjectUser
	pub fn new(json: Map<String, Value>) -> Self {
		InkProjectUser { json }
	}

	pub fn from_str(json: &str) -> serde_json::Result<Self> {
		serde_json::from_str(json.as_ref()).map(Self::new)
	}
}

/// Type state for builders to tell that some mandatory state has not yet been set
/// yet or to fail upon setting the same state multiple times.
pub struct Missing<S>(PhantomData<fn() -> S>);

mod state {
	//! Type states that tell what state of the project metadata has not
	//! yet been set properly for a valid construction.

	/// Type state for the name of the project.
	pub struct Name;

	/// Type state for the version of the project.
	pub struct Version;

	/// Type state for the authors of the project.
	pub struct Authors;
}

/// Build an [`InkProjectContract`], ensuring required fields are supplied
///
/// # Example
///
/// ```
/// # use crate::ink_metadata::InkProjectContract;
/// # use semver::Version;
/// # use url::Url;
/// // contract metadata with the minimum set of required fields
/// let metadata1: InkProjectContract =
///     InkProjectContract::build()
///         .name("example")
///         .version(Version::new(0, 1, 0))
///         .authors(vec!["author@example.com"])
///         .done();
///
/// // contract metadata with optional fields
/// let metadata2: InkProjectContract =
///     InkProjectContract::build()
///         .name("example")
///         .version(Version::new(0, 1, 0))
///         .authors(vec!["author@example.com"])
///         .description("description")
///         .documentation(Url::parse("http://example.com").unwrap())
///         .repository(Url::parse("http://example.com").unwrap())
///         .homepage(Url::parse("http://example.com").unwrap())
///         .done();
/// ```
#[allow(clippy::type_complexity)]
pub struct InkProjectContractBuilder<Name, Version, Authors> {
	contract: InkProjectContract,
	marker: PhantomData<fn() -> (Name, Version, Authors)>,
}

impl<V, A> InkProjectContractBuilder<Missing<state::Name>, V, A> {
	/// Set the contract name (required)
	pub fn name<S>(self, name: S) -> InkProjectContractBuilder<state::Name, V, A>
		where
			S: AsRef<str>,
	{
		InkProjectContractBuilder {
			contract: InkProjectContract {
				name: name.as_ref().to_owned(),
				..self.contract
			},
			marker: PhantomData,
		}
	}
}

impl<N, A> InkProjectContractBuilder<N, Missing<state::Version>, A> {
	/// Set the contract version (required)
	pub fn version(self, version: Version) -> InkProjectContractBuilder<N, state::Version, A> {
		InkProjectContractBuilder {
			contract: InkProjectContract {
				version,
				..self.contract
			},
			marker: PhantomData,
		}
	}
}

impl<N, V> InkProjectContractBuilder<N, V, Missing<state::Authors>> {
	/// Set the contract authors (required)
	pub fn authors<I, S>(
		self,
		authors: I,
	) -> InkProjectContractBuilder<N, V, state::Authors>
		where
			I: IntoIterator<Item = S>,
			S: AsRef<str>,
	{
		InkProjectContractBuilder {
			contract: InkProjectContract {
				authors: authors.into_iter().map(|s| s.as_ref().into()).collect(),
				..self.contract
			},
			marker: PhantomData,
		}
	}
}

impl<N, V, A> InkProjectContractBuilder<N, V, A> {
	/// Set the contract description (optional)
	pub fn description<S>(mut self, description: S) -> Self
		where
			S: AsRef<str>,
	{
		self.contract.description = Some(description.as_ref().to_owned());
		self
	}

	/// Set the contract documentation url (optional)
	pub fn documentation(mut self, documentation: Url) -> Self
	{
		self.contract.documentation = Some(documentation);
		self
	}

	/// Set the contract documentation url (optional)
	pub fn repository(mut self, repository: Url) -> Self {
		self.contract.repository = Some(repository);
		self
	}

	/// Set the contract homepage url (optional)
	pub fn homepage(mut self, homepage: Url) -> Self {
		self.contract.homepage = Some(homepage.into());
		self
	}

	/// Set the contract license (optional)
	pub fn license(mut self, license: License) -> Self {
		self.contract.license = Some(license);
		self
	}
}

impl InkProjectContractBuilder<state::Name, state::Version, state::Authors> {
	pub fn done(self) -> InkProjectContract {
		self.contract
	}
}

/// Serializes the given bytes as byte string.
fn serialize_as_byte_str<S>(bytes: &[u8], serializer: S) -> Result<S::Ok, S::Error>
	where
		S: serde::Serializer,
{
	if bytes.is_empty() {
		// Return empty string without prepended `0x`.
		return serializer.serialize_str("")
	}
	let mut hex = String::with_capacity(bytes.len() * 2 + 2);
	write!(hex, "0x").expect("failed writing to string");
	for byte in bytes {
		write!(hex, "{:02x}", byte).expect("failed writing to string");
	}
	serializer.serialize_str(&hex)
}
